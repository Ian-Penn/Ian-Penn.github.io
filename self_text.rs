// I feel like I'm fighting against std::path::Path.
// When I would be fine just using strings for all of the paths.

use std::path::Path;
use std::{fs, io};

const HEAD: &str = r#"
<link href="/css.css" rel="stylesheet" type="text/css">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
"#;

const NAV_BAR: &str = r#"
<header class="nav_bar">
    <a href="/index.html">Home</a>
    <a href="/projects.html">Projects</a>
    <a href="/blog.html">Blog</a>
</header>"#;

const FOOTER: &str = r#"
<footer>
    <p>This website is generated by <i><a href="/self_text.rs">this rust file</a></i>. Which puts its own source in the static website!</p>
</footer>"#;

fn escape_char(char: char) -> String {
    match char {
        '>' => "&gt;".to_string(),
        '<' => "&lt;".to_string(),
        _ => char.to_string(),
    }
}

fn md_parse(input: &str) -> String {
    let mut content = String::new();

    let mut link_title: Option<String> = None;
    let mut link_link: Option<String> = None;

    let mut in_header = false;
    let mut in_inline_code = false;

    let mut iter = input.chars().peekable();
    while let Some(char) = iter.next() {
        let next = iter.peek();

        if let Some(ref mut link) = link_link {
            if char == ')' {
                let title = link_title.unwrap();
                // dbg!(&link, &title);

                content.push_str(&format!(r#"<a href="{link}">{title}</a>"#));

                link_title = None;
                link_link = None;
            } else {
                link.push(char);
            }
            continue;
        }

        if let Some(ref mut title) = link_title {
            if char == ']' && next == Some(&'(') {
                link_link = Some(String::new());
                iter.next();
            } else {
                title.push_str(&escape_char(char));
            }
            continue;
        }

        if char == '\n' {
            if in_header {
                content.push_str("</h1>");
                in_header = false;
            }
            if next == Some(&'\n') {
                content.push_str("</br></br>");
                iter.next();
            }
            content.push('\n');
        } else if char == '[' {
            link_title = Some(String::new());
        } else if char == '#' && !in_inline_code {
            content.push_str(r#"<h1 class="md_head_1">"#);
            in_header = true;
        } else if char == '`' {
            if in_inline_code {
                content.push_str("</pre>");
                in_inline_code = false;
            } else {
                content.push_str(r#"<pre class="inline_code">"#);
                in_inline_code = true;
            }
        } else {
            content.push_str(&escape_char(char));
        }
    }

    let output = format!(
        r#"
        <!DOCTYPE html>
        <html>
            <head>
                <title>Home</title>
                {HEAD}
            </head>
            <body>
                <div class="container">
                    {NAV_BAR}
                        <div class="content">
                            {content}
                        </div>
                    {FOOTER}
                </div>
            </body>
        </html>"#
    );

    // println!("{output}");
    output
}

fn get_date(text: &str) -> String {
    let first_line = text.lines().nth(0).unwrap();
    first_line.to_string()
}

fn get_title(text: &str) -> &str {
    let second_line = text.lines().nth(1).unwrap();
    match second_line.strip_prefix("#") {
        Some(first_line) => first_line.trim(),
        None => todo!(), // Will i need this?
    }
}

#[derive(Debug)]
struct Post {
    title: String,
    path: String,
    date: String,
}

fn main() -> io::Result<()> {
    let site_dir = "./site";
    let out_dir = "./out";
    let self_dir = "./src/main.rs";

    // let map: Vec<(&str, &str)> = vec![];

    let _ = fs::remove_dir_all(out_dir);
    fs::create_dir(out_dir)?;

    let site_path = Path::new(site_dir);
    let out_path = Path::new(out_dir);

    for entry in fs::read_dir(site_dir)? {
        let dir = entry.unwrap();
        let path = dir.path();
        let file_path = path.to_str().unwrap();

        let is_normal_website_file = file_path.ends_with(".html")
            || file_path.ends_with(".js")
            || file_path.ends_with(".css");

        if is_normal_website_file {
            let destination = out_path.join(path.strip_prefix(site_dir).unwrap());

            println!("Copying file to: '{}'.", destination.to_str().unwrap());

            let text = fs::read_to_string(file_path)?;

            // for pair in &map {
            // text = text.replace(pair.0, pair.1);
            // }

            fs::write(destination, &text)?;
        } else if file_path.ends_with(".md") {
            let destination = format!(
                "{out_dir}{}.html",
                path.to_str()
                    .unwrap()
                    .strip_prefix(site_dir)
                    .unwrap()
                    .strip_suffix(".md")
                    .unwrap()
            );

            println!("Generating markdown at: '{destination}'.");

            let text = fs::read_to_string(file_path)?;
            let html = md_parse(&text);
            fs::write(destination, html)?;
        }
    }

    // blog posts
    {
        let mut posts: Vec<Post> = vec![];

        fs::create_dir(out_path.join("blog"))?;
        for entry in fs::read_dir(site_path.join("blog"))? {
            let path = entry.unwrap().path();
            let file_path = path.to_str().unwrap();

            let destination = format!(
                "{out_dir}{}.html",
                path.to_str()
                    .unwrap()
                    .strip_prefix(site_dir)
                    .unwrap()
                    .strip_suffix(".md")
                    .unwrap()
            );

            let text = fs::read_to_string(file_path)?;

            let title = get_title(&text);
            posts.push(Post {
                title: title.to_string(),
                path: format!(
                    "{}.html",
                    path.to_str()
                        .unwrap()
                        .strip_prefix(site_dir)
                        .unwrap()
                        .strip_suffix(".md")
                        .unwrap()
                ),
                date: get_date(&text),
            });

            println!("post '{title}'\n\t'{}'", &destination);

            let html = md_parse(text.split_once('\n').unwrap().1);
            fs::write(destination, html)?;
        }

        posts.sort_by(|a, b| b.date.cmp(&a.date));

        let mut post_list = String::new();

        for post in &posts {
            let text = format!(
                r#"
                <div class="post">
                    <a href="{}" class="title">{}</a>
                    <span class="date">{}</span>
                </div>
                "#,
                post.path, post.title, post.date
            );
            post_list.push_str(&text);
        }

        let html = format!(
            r#"
            <!DOCTYPE html>
            <html>
                <head>
                    <title>Home</title>
                    {HEAD}
                </head>
                <body>
                    <div class="container">
                        {NAV_BAR}
                            <div class="content">
                                {post_list}
                            </div>
                        {FOOTER}
                    </div>
                </body>
            </html>"#
        );

        let destination = out_path.join("blog.html");
        println!(
            "Generating markdown at: '{}'.",
            destination.to_str().unwrap()
        );
        fs::write(destination, html)?;
    }

    // THIS FILE FOR FUN!
    {
        let path = Path::new(out_dir).join("self_text.rs");
        let self_text = fs::read_to_string(self_dir)?;
        fs::write(&path, self_text)?;
        println!("Adding '{}' for fun.", path.to_str().unwrap());
    }

    Ok(())
}
