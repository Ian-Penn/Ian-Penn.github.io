<!DOCTYPE html>
<html>
<head>
	<title>Tetris</title>
	<meta charset="UTF-8">
	<style>
	html, body {
		height: 100%;
		margin: 0;
	}

	body {
		background: black;
		display: flex;
		align-items: center;
		justify-content: center;
	}

	canvas {
		border: 1px solid white;
	}
	</style>
</head>
<body>
<canvas width="100" height="100" id="game"></canvas>
<script>
const tetrominos = {
	I: {
		shape: [
			[0,0,0,0],
			[1,1,1,1],
			[0,0,0,0],
			[0,0,0,0],
		],
		color: "cyan",
	},
	J: {
		shape: [
			[1,0,0],
			[1,1,1],
			[0,0,0],
		],
		color: "blue",
	},
	L: {
		shape: [
			[0,0,1],
			[1,1,1],
			[0,0,0],
		],
		color: "orange",
	},
	O: {
		shape: [
			[1,1],
			[1,1],
		],
		color: "yellow",
	},
	S: {
		shape: [
			[0,1,1],
			[1,1,0],
			[0,0,0],
		],
		color: "green",
	},
	T: {
		shape: [
			[0,1,0],
			[1,1,1],
			[0,0,0],
		],
		color: "purple",
	},
	Z: {
		shape: [
			[1,1,0],
			[0,1,1],
			[0,0,0],
		],
		color: "red",
	},
};
const grid_width = 10;
const grid_height = 20;
const grid_size = 32;
const canvas_side_width = 64 * 4;
const canvas_width = grid_size * grid_width + canvas_side_width;
const canvas_height = grid_size * grid_height;
const rand = (min, max) => {
	return Math.floor(Math.random() * (max - min + 1)) + min;
};
const tetrominoSequence = [];
const getNextTetromino = () => {
	if (tetrominoSequence.length == 0) {
		const newSequence = [...Object.keys(tetrominos)];
		while (newSequence.length > 0) {
			tetrominoSequence.push(newSequence.splice(rand(0, newSequence.length - 1), 1)[0]);
		}
	}
	const name = tetrominoSequence.pop();
	const matrix = tetrominos[name].shape;
	const col = playfield[0].length / 2 - Math.ceil(matrix[0].length / 2);
	const row = -2;
	return {name, matrix, col, row};
};
const rotate = (matrix) => {
	const N = matrix.length - 1;
	const result = matrix.map((row, i) =>
		row.map((val, j) => matrix[N - j][i])
	);
	
	return result;
};
const isValidMove = (matrix, cellRow, cellCol) => {
	for (let row = 0; row < matrix.length; row++) {
		for (let col = 0; col < matrix[row].length; col++) {
			if (matrix[row][col] && (
				cellCol + col < 0 ||
				cellCol + col >= playfield[0].length ||
				cellRow + row >= playfield.length ||
				playfield[cellRow + row][cellCol + col])
			) {
				return false;
			}
		}
	}
	
	return true;
};
const placeTetromino = () => {
	for (let row = 0; row < tetromino.matrix.length; row++) {
		for (let col = 0; col < tetromino.matrix[row].length; col++) {
			if (tetromino.matrix[row][col]) {
	
				if (tetromino.row + row < 0) {
					return endGame();
				}
	
				playfield[tetromino.row + row][tetromino.col + col] = tetromino.name;
			}
		}
	}
	
	let hasClears = false;
	
	for (let row = playfield.length - 1; row >= 0; ) {
		if (playfield[row].every(cell => !!cell)) {
		
			level += 1;
			hasClears = true;
	
			for (let r = row; r >= 0; r--) {
				for (let c = 0; c < playfield[r].length; c++) {
					playfield[r][c] = playfield[r-1][c];
				}
			}
		}
		else {
			row--;
		}
	}
	tetromino = nextTetromino;
	nextTetromino = getNextTetromino();
	
	if (hasClears) reverseMode = !reverseMode;
};
const endGame = () => {
	gameOver = true;
};
const canvas = document.getElementById("game");
const context = canvas.getContext("2d");
let tetromino = null;
let nextTetromino = null;
let gameOver = false;
let tick = 0;
let level = 0;
let reverseMode = false;
let time = 0;
const playfield = [];
for (let row = -2; row < grid_height; row++) {
	playfield[row] = [];
	for (let col = 0; col < grid_width; col++) {
		playfield[row][col] = "";
	}
}
const up = (keyName) => {
	const matrix = rotate(tetromino.matrix);
	if (isValidMove(matrix, tetromino.row, tetromino.col)) {
		tetromino.matrix = matrix;
	}
};
const down = (keyName) => {
	const row = tetromino.row + 1;
	
	if (!isValidMove(tetromino.matrix, row, tetromino.col)) {
		tetromino.row = row - 1;
	
		placeTetromino();
		return;
	}
	
	tetromino.row = row;
};
const left = (keyName) => {
	const col = tetromino.col - 1;
	if (isValidMove(tetromino.matrix, tetromino.row, col)) {tetromino.col = col;}
};
const right = (keyName) => {
	const col = tetromino.col + 1;
	if (isValidMove(tetromino.matrix, tetromino.row, col)) {tetromino.col = col;}
};
const restart = (keyName) => {
	tetromino = getNextTetromino();
	nextTetromino = getNextTetromino();
	gameOver = false;
	tick = 0;
	level = 0;
	for (let row = -2; row < grid_height; row++) {
		playfield[row] = [];
		for (let col = 0; col < grid_width; col++) {
			playfield[row][col] = "";
		}
	}
};
const onKeyPress = (keyName) => {
	switch (keyName) {
	case "ArrowUp": {
		up()
		break;
	}
	case "ArrowDown": {
		down()
		break;
	}
	case "ArrowLeft": {
		left()
		break;
	}
	case "ArrowRight": {
		right()
		break;
	}
	case "Digit1": {
		up()
		break;
	}
	case "Digit2": {
		down()
		break;
	}
	case "Digit3": {
		left()
		break;
	}
	case "Digit4": {
		right()
		break;
	}
	case "Digit5": {
		restart()
		break;
	}
	case "Digit6": {
		restart()
		break;
	}
	case "Digit0": {
		level = level + 1;
		break;
	}
	}
};
const onStep = () => {
	if (reverseMode) {
		canvas.style.scale = "-1";
	} else {
		canvas.style.scale = "1";
	}
	
	time++;
	// canvas.style.rotate = `${time/40}deg`;
	
	if (gameOver) {
		context.fillStyle = 'black';
		context.globalAlpha = 0.75;
		context.fillRect(0, canvas.height / 2 - 30, canvas.width, 60);
		
		context.globalAlpha = 1;
		context.fillStyle = 'white';
		context.font = '36px monospace';
		context.textAlign = 'center';
		context.textBaseline = 'middle';
		context.fillText('GAME OVER!', canvas.width / 2, canvas.height / 2);
		return;
	}
	context.clearRect(0, 0, canvas.width, canvas.height);
	context.fillStyle = "white";
	context.fillRect(0, 0, canvas.width - canvas_side_width, canvas.height);
	for (let row = 0; row < grid_height; row++) {
		for (let col = 0; col < grid_width; col++) {
			if (playfield[row][col] != "") {
				context.fillStyle = tetrominos[playfield[row][col]].color;
				context.fillRect(col * grid_size, row * grid_size, grid_size-1, grid_size-1);
			} else {
				context.fillStyle = "black";
				context.fillRect(col * grid_size, row * grid_size, grid_size-1, grid_size-1);
			}
		}
	}
	tick += 1;
	if (tick > 30 * Math.pow(0.954842, level)) {
		tetromino.row++;
		tick = 0;
	
		if (!isValidMove(tetromino.matrix, tetromino.row, tetromino.col)) {
			tetromino.row--;
			placeTetromino();
		}
	}
	
	context.fillStyle = tetrominos[tetromino.name].color;
	
	for (let row = 0; row < tetromino.matrix.length; row++) {
		for (let col = 0; col < tetromino.matrix[row].length; col++) {
			if (tetromino.matrix[row][col]) {
				context.fillRect((tetromino.col + col) * grid_size, (tetromino.row + row) * grid_size, grid_size-1, grid_size-1);
			}
		}
	}
	
	context.globalAlpha = 1;
	context.fillStyle = 'white';
	context.font = '36px monospace';
	context.textAlign = 'center';
	context.textBaseline = 'middle';
	context.fillText("level: " + level, canvas.width - canvas_side_width/2, 36);
	context.fillText("next: " + nextTetromino.name, canvas.width - canvas_side_width/2, 36 * 2);
};
const main = () => {
	tetromino = getNextTetromino();
	nextTetromino = getNextTetromino();
	canvas.width = canvas_width;
	canvas.height = canvas_height;
	document.addEventListener("keydown", (e) => {
		console.log(e);
		// if (e.repeat) return;
		onKeyPress(e.code);
	});
	// setInterval(() => {
	// 	onStep();
	// }, 500);
	const loop = () => {
		requestAnimationFrame(loop);
		onStep();
	};
	requestAnimationFrame(loop);
};
main()

</script>
</body>
</html>
